<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes"/>
    <link rel="icon" type="image/x-icon" href="favicon.png">
    <style>
        html {
            font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            background-color: #fff;
            font-size: 16px;
        }

        body {
            color: #4a4a4a;
            margin: 8px;
            font-size: 1em;
            font-weight: 400;
        }

        header {
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
        }

        main {
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        a {
            color: #3273dc;
            cursor: pointer;
            text-decoration: none;
        }

        a:hover {
            color: #000;
        }

        button {
            color: #fff;
            background-color: #3298dc;
            border-color: transparent;
            cursor: pointer;
            text-align: center;
        }

        button:hover {
            background-color: #2793da;
            flex: none;
        }

        .spacer {
            flex: auto;
        }

        .small {
            font-size: 0.75rem;
        }

        footer {
            margin-top: 16px;
            display: flex;
            align-items: center;
        }

        .header-label {
            margin-right: 4px;
        }

        .benchmark-set {
            margin: 8px 0;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .benchmark-title {
            font-size: 3rem;
            font-weight: 600;
            word-break: break-word;
            text-align: center;
        }

        .benchmark-graphs {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .benchmark-chart {
            max-width: 550px;
        }
    </style>
    <title>Benchmarks</title>
</head>

<body>
<header id="header">
    <div class="header-item">
        <strong class="header-label">Last Update:</strong>
        <span id="last-update"></span>
    </div>
    <div class="header-item">
        <strong class="header-label">Repository:</strong>
        <a id="repository-link" rel="noopener"></a>
    </div>
</header>
<main id="main"></main>
<footer>
    <button id="dl-button">Download data as JSON</button>
    <div class="spacer"></div>
    <div class="small">Powered by <a rel="noopener" href="https://github.com/marketplace/actions/continuous-benchmark">github-action-benchmark</a>
    </div>
</footer>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="data.js"></script>
<script id="main-script">
    'use strict';
    (function () {
        // Colors from https://github.com/github/linguist/blob/master/lib/linguist/languages.yml
        const toolColors = {
            cargo: '#dea584',
            go: '#00add8',
            benchmarkjs: '#f1e05a',
            benchmarkluau: '#000080',
            pytest: '#3572a5',
            googlecpp: '#f34b7d',
            catch2: '#f34b7d',
            julia: '#a270ba',
            jmh: '#b07219',
            benchmarkdotnet: '#178600',
            customBiggerIsBetter: '#38ff38',
            customSmallerIsBetter: '#ff3838',
            _: '#333333'
        };

        function stringToColor(str) {
            // Random colours are generally pretty disgusting...
            const MAP = {
                "vortex-pushdown-disabled": '#3CD50C',
                "vortex-pushdown-enabled": '#7437D0',
                "arrow": '#E8A807',
                "parquet": '#D7B945',
                "persistent_compressed_vortex": '#F34B7D',
                "persistent_uncompressed_vortex": '#4DBDFB',
            };

            if (MAP[str]) {
                return MAP[str];
            } else {
                console.log("Using random color for: " + str)
            }

            // Hash the input string using SHA-256
            const hash = hashCode(str);

            // Extract RGB values from the hash
            const r = (hash & 0xFF0000) >> 16;
            const g = (hash & 0x00FF00) >> 8;
            const b = hash & 0x0000FF;

            // Return a CSS color string
            const hexColor = ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');
            return `#${hexColor}`;
        }

        function init() {
            function collectBenchesPerTestCase(entries) {
                // It's desirable for all our graphs to line up in terms of X-axis.
                // As such, we collect all unique {commit,entry} first, and then assign
                // data points to them for each graph. Commits are sorted by date.
                const commits = [];
                const dates = [];
                entries.sort((a, b) => new Date(a.commit.timestamp) - new Date(b.commit.timestamp)).forEach(entry => {
                    commits.push(entry.commit);
                    dates.push(entry.date);
                });


                const map = new Map();
                entries.forEach((entry, entryIdx) => {
                    const {tool, benches} = entry;

                    for (const bench of benches) {
                        const {name, range, unit, value} = bench;
                        // Normalize name
                        let [q, seriesName] = name.split("/");
                        let prettyQ = q.replace("_", " ").toUpperCase();

                        let arr = map.get(prettyQ);
                        if (arr === undefined) {
                            map.set(prettyQ, {
                                commits,
                                unit: unit,
                                series: new Map(),
                            });
                            arr = map.get(prettyQ);
                        }

                        let series = arr.series.get(seriesName);
                        if (series === undefined) {
                            arr.series.set(seriesName, new Array(entries.length).fill(null));
                            series = arr.series.get(seriesName);
                        }
                        series[entryIdx] = {range, value};
                    }
                });
                return map;
            }

            const data = window.BENCHMARK_DATA;

            // Render header
            document.getElementById('last-update').textContent = new Date(data.lastUpdate).toString();
            const repoLink = document.getElementById('repository-link');
            repoLink.href = data.repoUrl;
            repoLink.textContent = data.repoUrl;

            // Render footer
            document.getElementById('dl-button').onclick = () => {
                const dataUrl = 'data:,' + JSON.stringify(data, null, 2);
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = 'benchmark_data.json';
                a.click();
            };

            // Prepare data points for charts
            return Object.keys(data.entries).map(name => ({
                name,
                dataSet: collectBenchesPerTestCase(data.entries[name]),
            }));
        }

        function renderAllChars(dataSets) {

            function renderGraph(parent, name, dataset) {
                const canvas = document.createElement('canvas');
                canvas.className = 'benchmark-chart';
                parent.appendChild(canvas);

                const data = {
                    labels: dataset.commits.map(commit => commit.id.slice(0, 7)),
                    datasets: Array.from(dataset.series).map(([name, benches]) => {
                        const color = stringToColor(name);
                        return {
                            label: name,
                            data: benches.map(b => b ? b.value : null),
                            borderColor: color,
                            // backgroundColor: color + '60', // Add alpha for #rrggbbaa
                        };
                    }),
                };
                const options = {
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: name,
                                padding: {bottom: 50},
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: dataset.commits.length > 0 ? dataset.unit : '',
                            },
                            suggestedMin: 0,
                        },
                    },
                    tooltips: {
                        callbacks: {
                            afterTitle: items => {
                                const {index} = items[0];
                                const commit = dataset.commits[index];
                                return '\n' + commit.message + '\n\n' + commit.timestamp + ' committed by @' + commit.committer.username + '\n';
                            },
                            label: item => {
                                const seriesName = Array.from(dataset.series.keys())[item.datasetIndex];
                                let label = item.value;
                                const {range, unit} = dataset.series.get(seriesName)[item.index];
                                label += ' ' + unit;
                                if (range) {
                                    label += ' (' + range + ')';
                                }
                                return label;
                            },
                            afterLabel: item => {
                                const seriesName = Array.from(dataset.series.keys())[item.datasetIndex];
                                const {extra} = dataset.series.get(seriesName)[item.index];
                                return extra ? '\n' + extra : '';
                            }
                        }
                    },
                    onClick: (_mouseEvent, activeElems) => {
                        if (activeElems.length === 0) {
                            return;
                        }
                        // XXX: Undocumented. How can we know the index?
                        const index = activeElems[0]._index;
                        const url = dataset[index].commit.url;
                        window.open(url, '_blank');
                    },
                };

                new Chart(canvas, {
                    type: 'line',
                    data,
                    options,
                });
            }

            function renderBenchSet(name, benchSet, main) {
                const setElem = document.createElement('div');
                setElem.className = 'benchmark-set';
                main.appendChild(setElem);

                const nameElem = document.createElement('h1');
                nameElem.className = 'benchmark-title';
                nameElem.textContent = name;
                setElem.appendChild(nameElem);

                const graphsElem = document.createElement('div');
                graphsElem.className = 'benchmark-graphs';
                setElem.appendChild(graphsElem);

                for (const [benchName, benches] of benchSet.entries()) {
                    renderGraph(graphsElem, benchName, benches)
                }
            }

            const main = document.getElementById('main');
            for (const {name, dataSet} of dataSets) {
                renderBenchSet(name, dataSet, main);
            }
        }

        renderAllChars(init()); // Start
    })();
</script>
</body>
</html>
